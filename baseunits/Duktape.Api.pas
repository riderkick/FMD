unit Duktape.Api;

interface

const
  {$IF Defined(WIN32)}
  LIB_DUKTAPE = 'duktape32.dll';
  PREFIX = '';
  {$ELSEIF Defined(WIN64)}
  LIB_DUKTAPE = 'duktape64.dll';
  PREFIX = '';
  {$ELSEIF Defined(ANDROID)}
  LIB_DUKTAPE = 'libduktape_android.a';
  PREFIX = '';
  {$ELSEIF Defined(IOS)}
  LIB_DUKTAPE = 'libduktape_ios.a';
  PREFIX = '';
  {$ELSEIF Defined(MACOS32)}
  LIB_DUKTAPE = 'libduktape_osx32.dylib';
  PREFIX = '_';
  {$ELSEIF Defined(MACOS64)}
  LIB_DUKTAPE = 'libduktape_osx64.a';
  PREFIX = '';
  {$ELSEIF Defined(LINUX)}
  LIB_DUKTAPE = 'libduktape_linux64.so';
  PREFIX = '';
  {$ELSE}
    {$MESSAGE Error 'Unsupported platform'}
  {$ENDIF}

(*
 *  duk_config.h configuration header generated by genconfig.py.
 *
 *  Git commit d7fdb67f18561a50e06bafd196c6b423af9ad6fe (v2.3.0).
 *  Git branch: master
 *
 *  Supported platforms:
 *      - Mac OSX, iPhone, Darwin
 *      - Orbis
 *      - OpenBSD
 *      - Generic BSD
 *      - Atari ST TOS
 *      - AmigaOS
 *      - Durango (XboxOne)
 *      - Windows
 *      - Flashplayer (Crossbridge)
 *      - QNX
 *      - TI-Nspire
 *      - Emscripten
 *      - Linux
 *      - Solaris
 *      - AIX
 *      - HPUX
 *      - Generic POSIX
 *      - Cygwin
 *      - Generic UNIX
 *      - Generic fallback
 *
 *  Supported architectures:
 *      - x86
 *      - x64
 *      - x32
 *      - ARM 32-bit
 *      - ARM 64-bit
 *      - MIPS 32-bit
 *      - MIPS 64-bit
 *      - PowerPC 32-bit
 *      - PowerPC 64-bit
 *      - SPARC 32-bit
 *      - SPARC 64-bit
 *      - SuperH
 *      - Motorola 68k
 *      - Emscripten
 *      - Generic
 *
 *  Supported compilers:
 *      - Clang
 *      - GCC
 *      - MSVC
 *      - Emscripten
 *      - TinyC
 *      - VBCC
 *      - Bruce's C compiler
 *      - Generic
 *
 *)

type MarshaledAString = ^AnsiChar;

type
  TDukUInt8 = UInt8;
  TDukInt8 = Int8;
  TDukUInt16 = UInt16;
  TDukInt16 = Int16;
  TDukUInt32 = UInt32;
  TDukInt32 = Int32;
  TDukUInt64 = UInt32;
  TDukInt64 = Int32;
  TDukUInt = Cardinal;
  TDukInt = Integer;
  TDukSize = NativeUInt;
  TDukPtrDiff = NativeInt;
  TDukSmallUInt = Cardinal;
  TDukSmallInt = Integer;
  TDukBool = TDukSmallUInt;
  TDukIdx = TDukInt;
  TDukUIdx = TDukUInt;
  TDukUArrIdx = TDukUInt;
  TDukRet = TDukSmallInt;
  TDukErrCode = TDukInt;
  TDukCodepoint = TDukInt;
  TDukUCodepoint = TDukUInt;
  TDukFloat = Single;
  TDukDouble = Double;

type
  PDukUInt8 = ^TDukUInt8;
  PDukInt8 = ^TDukInt8;
  PDukUInt16 = ^TDukUInt16;
  PDukInt16 = ^TDukInt16;
  PDukUInt32 = ^TDukUInt32;
  PDukInt32 = ^TDukInt32;
  PDukUInt64 = ^TDukUInt64;
  PDukInt64 = ^TDukInt64;
  PDukUInt = ^TDukUInt;
  PDukInt = ^TDukInt;
  PDukSize = ^TDukSize;
  PDukPtrDiff = ^TDukPtrDiff;
  PDukSmallUInt = ^TDukSmallUInt;
  PDukSmallInt = ^TDukSmallInt;
  PDukBool = ^TDukBool;
  PDukIdx = ^TDukIdx;
  PDukUIdx = ^TDukUIdx;
  PDukUArrIdx = ^TDukUArrIdx;
  PDukRet = ^TDukRet;
  PDukErrCode = ^TDukErrCode;
  PDukCodepoint = ^TDukCodepoint;
  PDukUCodepoint = ^TDukUCodepoint;
  PDukFloat = ^TDukFloat;
  PDukDouble = ^TDukDouble;

type
  TDukUIntLeast8 = TDukUInt8;
  TDukIntLeast8 = TDukInt8;
  TDukUIntLeast16 = TDukUInt16;
  TDukIntLeast16 = TDukInt16;
  TDukUIntLeast32 = TDukUInt32;
  TDukIntLeast32 = TDukInt32;
  TDukUIntLeast64 = TDukUInt64;
  TDukIntLeast64 = TDukInt64;

type
  TDukUIntFast8 = TDukUInt8;
  TDukIntFast8 = TDukInt8;
  TDukUIntFast16 = TDukUInt16;
  TDukIntFast16 = TDukInt16;
  TDukUIntFast32 = TDukUInt32;
  TDukIntFast32 = TDukInt32;
  TDukUIntFast64 = TDukUInt64;
  TDukIntFast64 = TDukInt64;
  TDukUIntFast = TDukUIntFast32;
  TDukIntFast = TDukIntFast32;
  TDukSmallUIntFast = TDukUIntFast16;
  TDukSmallIntFast = TDukIntFast16;

type
  TDukUIntMax = TDukUInt64;
  TDukIntMax = TDukInt64;

const
  DUK_UINT8_MIN        =  $00;
  DUK_UINT8_MAX        =  $FF;
  DUK_INT8_MIN         = -$80;
  DUK_INT8_MAX         =  $7F;
  DUK_UINT_LEAST8_MIN  =  $00;
  DUK_UINT_LEAST8_MAX  =  $FF;
  DUK_INT_LEAST8_MIN   = -$80;
  DUK_INT_LEAST8_MAX   =  $7F;
  DUK_UINT_FAST8_MIN   =  $00;
  DUK_UINT_FAST8_MAX   =  $FF;
  DUK_INT_FAST8_MIN    = -$80;
  DUK_INT_FAST8_MAX    =  $7F;
  DUK_UINT16_MIN       =  $0000;
  DUK_UINT16_MAX       =  $FFFF;
  DUK_INT16_MIN        = -$8000;
  DUK_INT16_MAX        =  $7FFF;
  DUK_UINT_LEAST16_MIN =  $0000;
  DUK_UINT_LEAST16_MAX =  $FFFF;
  DUK_INT_LEAST16_MIN  = -$8000;
  DUK_INT_LEAST16_MAX  =  $7FFF;
  DUK_UINT_FAST16_MIN  =  $0000;
  DUK_UINT_FAST16_MAX  =  $FFFF;
  DUK_INT_FAST16_MIN   = -$8000;
  DUK_INT_FAST16_MAX   =  $7FFF;
  DUK_UINT32_MIN       =  $00000000;
  DUK_UINT32_MAX       =  $FFFFFFFF;
  DUK_INT32_MIN        = -$80000000;
  DUK_INT32_MAX        =  $7FFFFFFF;
  DUK_UINT_LEAST32_MIN =  $00000000;
  DUK_UINT_LEAST32_MAX =  $FFFFFFFF;
  DUK_INT_LEAST32_MIN  = -$80000000;
  DUK_INT_LEAST32_MAX  =  $7FFFFFFF;
  DUK_UINT_FAST32_MIN  =  $00000000;
  DUK_UINT_FAST32_MAX  =  $FFFFFFFF;
  DUK_INT_FAST32_MIN   = -$80000000;
  DUK_INT_FAST32_MAX   =  $7FFFFFFF;
  DUK_UINT64_MIN       =  $0000000000000000;
  DUK_UINT64_MAX       =  $FFFFFFFFFFFFFFFF;
  DUK_INT64_MIN        = -$8000000000000000;
  DUK_INT64_MAX        =  $7FFFFFFFFFFFFFFF;
  DUK_UINT_LEAST64_MIN =  $0000000000000000;
  DUK_UINT_LEAST64_MAX =  $FFFFFFFFFFFFFFFF;
  DUK_INT_LEAST64_MIN  = -$8000000000000000;
  DUK_INT_LEAST64_MAX  =  $7FFFFFFFFFFFFFFF;
  DUK_UINT_FAST64_MIN  =  $0000000000000000;
  DUK_UINT_FAST64_MAX  =  $FFFFFFFFFFFFFFFF;
  DUK_INT_FAST64_MIN   = -$8000000000000000;
  DUK_INT_FAST64_MAX   =  $7FFFFFFFFFFFFFFF;

const
  DUK_UINTMAX_MIN = DUK_UINT64_MIN;
  DUK_UINTMAX_MAX = DUK_UINT64_MAX;
  DUK_INTMAX_MIN  = DUK_INT64_MIN;
  DUK_INTMAX_MAX  = DUK_INT64_MAX;

const
  DUK_UINT_MIN            = DUK_UINT32_MIN;
  DUK_UINT_MAX            = DUK_UINT32_MAX;
  DUK_INT_MIN             = DUK_INT32_MIN;
  DUK_INT_MAX             = DUK_INT32_MAX;
  DUK_UINT_FAST_MIN       = DUK_UINT_FAST32_MIN;
  DUK_UINT_FAST_MAX       = DUK_UINT_FAST32_MAX;
  DUK_INT_FAST_MIN        = DUK_INT_FAST32_MIN;
  DUK_INT_FAST_MAX        = DUK_INT_FAST32_MAX;
  DUK_SMALL_UINT_MIN      = DUK_UINT32_MIN;
  DUK_SMALL_UINT_MAX      = DUK_UINT32_MAX;
  DUK_SMALL_INT_MIN       = DUK_INT32_MIN;
  DUK_SMALL_INT_MAX       = DUK_INT32_MAX;
  DUK_SMALL_UINT_FAST_MIN = DUK_UINT16_MIN;
  DUK_SMALL_UINT_FAST_MAX = DUK_UINT16_MAX;
  DUK_SMALL_INT_FAST_MIN  = DUK_INT16_MIN;
  DUK_SMALL_INT_FAST_MAX  = DUK_INT16_MAX;
  DUK_BOOL_MIN            = DUK_SMALL_INT_MIN;
  DUK_BOOL_MAX            = DUK_SMALL_INT_MAX;
  DUK_IDX_MIN             = DUK_INT_MIN;
  DUK_IDX_MAX             = DUK_INT_MAX;
  DUK_UIDX_MIN            = DUK_UINT_MIN;
  DUK_UIDX_MAX            = DUK_UINT_MAX;
  DUK_UARRIDX_MIN         = DUK_UINT_MIN;
  DUK_UARRIDX_MAX         = DUK_UINT_MAX;
  DUK_ERRCODE_MIN         = DUK_INT_MIN;
  DUK_ERRCODE_MAX         = DUK_INT_MAX;
  DUK_CODEPOINT_MIN       = DUK_INT_MIN;
  DUK_CODEPOINT_MAX       = DUK_INT_MAX;
  DUK_UCODEPOINT_MIN      = DUK_UINT_MIN;
  DUK_UCODEPOINT_MAX      = DUK_UINT_MAX;
  DUK_RET_MIN             = DUK_SMALL_INT_MIN;
  DUK_RET_MAX             = DUK_SMALL_INT_MAX;

(*
 *  Duktape public API for Duktape 2.1.0.
 *
 *  See the API reference for documentation on call semantics.  The exposed,
 *  supported API is between the "BEGIN PUBLIC API" and "END PUBLIC API"
 *  comments.  Other parts of the header are Duktape internal and related to
 *  e.g. platform/compiler/feature detection.
 *
 *  Git commit a459cf3c9bd1779fc01b435d69302b742675a08f (v2.2.0).
 *  Git branch master.
 *
 *  See Duktape AUTHORS.rst and LICENSE.txt for copyright and
 *  licensing information.
 *)

(*
 *  ===============
 *  Duktape license
 *  ===============
 *
 *  (http://opensource.org/licenses/MIT)
 *
 *  Copyright (c) 2013-2018 by Duktape authors (see AUTHORS.rst)
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 *)

(*
 *  ===============
 *  Duktape authors
 *  ===============
 *
 *  Copyright
 *  =========
 *
 *  Duktape copyrights are held by its authors.  Each author has a copyright
 *  to their contribution, and agrees to irrevocably license the contribution
 *  under the Duktape ``LICENSE.txt``.
 *
 *  Authors
 *  =======
 *
 *  Please include an e-mail address, a link to your GitHub profile, or something
 *  similar to allow your contribution to be identified accurately.
 *
 *  The following people have contributed code, website contents, or Wiki contents,
 *  and agreed to irrevocably license their contributions under the Duktape
 *  ``LICENSE.txt`` (in order of appearance):
 *
 *  * Sami Vaarala <sami.vaarala@iki.fi>
 *  * Niki Dobrev
 *  * Andreas \u00d6man <andreas@lonelycoder.com>
 *  * L\u00e1szl\u00f3 Lang\u00f3 <llango.u-szeged@partner.samsung.com>
 *  * Legimet <legimet.calc@gmail.com>
 *  * Karl Skomski <karl@skomski.com>
 *  * Bruce Pascoe <fatcerberus1@gmail.com>
 *  * Ren\u00e9 Hollander <rene@rene8888.at>
 *  * Julien Hamaide (https://github.com/crazyjul)
 *  * Sebastian G\u00f6tte (https://github.com/jaseg)
 *  * Tomasz Magulski (https://github.com/magul)
 *  * \D. Bohdan (https://github.com/dbohdan)
 *  * Ond\u0159ej Jirman (https://github.com/megous)
 *  * Sa\u00fal Ibarra Corretg\u00e9 <saghul@gmail.com>
 *  * Jeremy HU <huxingyi@msn.com>
 *  * Ole Andr\u00e9 Vadla Ravn\u00e5s (https://github.com/oleavr)
 *  * Harold Brenes (https://github.com/harold-b)
 *  * Oliver Crow (https://github.com/ocrow)
 *  * Jakub Ch\u0142api\u0144ski (https://github.com/jchlapinski)
 *  * Brett Vickers (https://github.com/beevik)
 *  * Dominik Okwieka (https://github.com/okitec)
 *  * Remko Tron\u00e7on (https://el-tramo.be)
 *  * Romero Malaquias (rbsm@ic.ufal.br)
 *  * Michael Drake <michael.drake@codethink.co.uk>
 *  * Steven Don (https://github.com/shdon)
 *  * Simon Stone (https://github.com/sstone1)
 *  * \J. McC. (https://github.com/jmhmccr)
 *  * Jakub Nowakowski (https://github.com/jimvonmoon)
 *  * Tommy Nguyen (https://github.com/tn0502)
 *  * Fabrice Fontaine (https://github.com/ffontaine)
 *  * Christopher Hiller (https://github.com/boneskull)
 *  * Gonzalo Diethelm (https://github.com/gonzus)
 *  * Michal Kasperek (https://github.com/michalkas)
 *  * Andrew Janke (https://github.com/apjanke)
 *  * Steve Fan (https://github.com/stevefan1999)
 *
 *  Other contributions
 *  ===================
 *
 *  The following people have contributed something other than code (e.g. reported
 *  bugs, provided ideas, etc; roughly in order of appearance):
 *
 *  * Greg Burns
 *  * Anthony Rabine
 *  * Carlos Costa
 *  * Aur\u00e9lien Bouilland
 *  * Preet Desai (Pris Matic)
 *  * judofyr (http://www.reddit.com/user/judofyr)
 *  * Jason Woofenden
 *  * Micha\u0142 Przyby\u015b
 *  * Anthony Howe
 *  * Conrad Pankoff
 *  * Jim Schimpf
 *  * Rajaran Gaunker (https://github.com/zimbabao)
 *  * Andreas \u00d6man
 *  * Doug Sanden
 *  * Josh Engebretson (https://github.com/JoshEngebretson)
 *  * Remo Eichenberger (https://github.com/remoe)
 *  * Mamod Mehyar (https://github.com/mamod)
 *  * David Demelier (https://github.com/markand)
 *  * Tim Caswell (https://github.com/creationix)
 *  * Mitchell Blank Jr (https://github.com/mitchblank)
 *  * https://github.com/yushli
 *  * Seo Sanghyeon (https://github.com/sanxiyn)
 *  * Han ChoongWoo (https://github.com/tunz)
 *  * Joshua Peek (https://github.com/josh)
 *  * Bruce E. Pascoe (https://github.com/fatcerberus)
 *  * https://github.com/Kelledin
 *  * https://github.com/sstruchtrup
 *  * Michael Drake (https://github.com/tlsa)
 *  * https://github.com/chris-y
 *  * Laurent Zubiaur (https://github.com/lzubiaur)
 *  * Neil Kolban (https://github.com/nkolban)
 *  * Wilhelm Wanecek (https://github.com/wanecek)
 *  * Andrew Janke (https://github.com/apjanke)
 *
 *  If you are accidentally missing from this list, send me an e-mail
 *  (``sami.vaarala@iki.fi``) and I'll fix the omission.
 *)

(*
 *  BEGIN PUBLIC API
 *)

(*
 *  Version and Git commit identification
 *)

(* Duktape version, (major * 10000) + (minor * 100) + patch.  Allows C code
 * to #if (DUK_VERSION >= NNN) against Duktape API version.  The same value
 * is also available to ECMAscript code in Duktape.version.  Unofficial
 * development snapshots have 99 for patch level (e.g. 0.10.99 would be a
 * development version after 0.10.0 but before the next official release).
 *)
const
  DUK_VERSION = 20300;

(* Git commit, describe, and branch for Duktape build.  Useful for
 * non-official snapshot builds so that application code can easily log
 * which Duktape snapshot was used.  Not available in the ECMAscript
 * environment.
 *)
const
  DUK_GIT_COMMIT   = 'd7fdb67f18561a50e06bafd196c6b423af9ad6fe';
  DUK_GIT_DESCRIBE = 'v2.3.0';
  DUK_GIT_BRANCH   = 'master';

(*
 *  Public API specific typedefs
 *
 *  Many types are wrapped by Duktape for portability to rare platforms
 *  where e.g. 'int' is a 16-bit type.  See practical typing discussion
 *  in Duktape web documentation.
 *)

type
  PDukContext = Pointer;

type
  TDukAllocFunction = function(udata: Pointer; size: TDukSize): Pointer; cdecl;
  TDukReallocFunction = function(udata: Pointer; ptr: Pointer; size: TDukSize): Pointer; cdecl;
  TDukFreeFunction = procedure(udata: Pointer; ptr: Pointer); cdecl;
  TDukCFunction = function(ctx: PDukContext): TDukRet; cdecl;
  TDukFatalFunction = procedure(udata: Pointer; const msg: MarshaledAString); cdecl;
  TDukDecodeCharFunction = procedure(udata: Pointer; codepoint: TDukCodepoint); cdecl;
  TDukMapCharFunction = function(udata: Pointer; codepoint: TDukCodepoint): TDukCodepoint; cdecl;
  TDukSafeCallFunction = function(ctx: PDukContext; udata: Pointer): TDukRet; cdecl;
  TDukDebugReadFunction = function(udata: Pointer; buffer: MarshaledAString; length: TDukSize): TDukSize; cdecl;
  TDukDebugWriteFunction = function(udata: Pointer; const buffer: MarshaledAString; length: TDukSize): TDukSize; cdecl;
  TDukDebugPeekFunction = function(udata: Pointer): TDukSize; cdecl;
  TDukDebugReadFlushFunction = procedure(udata: Pointer); cdecl;
  TDukDebugWriteFlushFunction = procedure(udata: Pointer); cdecl;
  TDukDebugRequestFunction = function(ctx: PDukContext; udata: Pointer; nvalues: TDukIdx): TDukIdx; cdecl;
  TDukDebugDetachedFunction = procedure(ctx: PDukContext; udata: Pointer); cdecl;

type
  PDukThreadState = ^TDukThreadState;
  TDukThreadState = record
    { Enough space to hold internal suspend/resume structure.
      This is rather awkward and to be fixed when the internal
      structure is visible for the public API header. }
    Data: array [0..127] of Byte;
  end;

type
  PDukMemoryFunctions = ^TDukMemoryFunctions;
  TDukMemoryFunctions = record
    AllocFunc: TDukAllocFunction;
    ReallocFunc: TDukReallocFunction;
    FreeFunc: TDukFreeFunction;
    UserData: Pointer;
  end;

type
  PDukFunctionListEntry = ^TDukFunctionListEntry;
  TDukFunctionListEntry = record
    Key: MarshaledAString;
    Value: TDukCFunction;
    NumArgs: TDukIdx;
  end;

type
  PDukNumberListEntry = ^TDukNumberListEntry;
  TDukNumberListEntry = record
    Key: MarshaledAString;
    Value: TDukDouble;
  end;

type
  PDukTimeComponents = ^TDukTimeComponents;
  TDukTimeComponents = record
    Year: TDukDouble;
    Month: TDukDouble;
    Day: TDukDouble;
    Hours: TDukDouble;
    Minutes: TDukDouble;
    Seconds: TDukDouble;
    Milliseconds: TDukDouble;
    Weekday: TDukDouble;
  end;

(*
 *  Constants
 *)

(* Duktape debug protocol version used by this build. *)
const
  DUK_DEBUG_PROTOCOL_VERSION = 2;

(* Used to represent invalid index; if caller uses this without checking,
 * this index will map to a non-existent stack entry.  Also used in some
 * API calls as a marker to denote "no value".
 *)
const
  DUK_INVALID_INDEX = DUK_IDX_MIN;

(* Indicates that a native function does not have a fixed number of args,
 * and the argument stack should not be capped/extended at all.
 *)
const
  DUK_VARARGS = -1;

(* Number of value stack entries (in addition to actual call arguments)
 * guaranteed to be allocated on entry to a Duktape/C function.
 *)
const
  DUK_API_ENTRY_STACK = 64;

(* Value types, used by e.g. duk_get_type() *)
const
  DUK_TYPE_MIN       = 0;
  DUK_TYPE_NONE      = 0; (* no value, e.g. invalid index *)
  DUK_TYPE_UNDEFINED = 1; (* ECMAScript undefined *)
  DUK_TYPE_NULL      = 2; (* ECMAScript null *)
  DUK_TYPE_BOOLEAN   = 3; (* ECMAScript boolean: 0 or 1 *)
  DUK_TYPE_NUMBER    = 4; (* ECMAScript number: double *)
  DUK_TYPE_STRING    = 5; (* ECMAScript string: CESU-8 / extended UTF-8 encoded *)
  DUK_TYPE_OBJECT    = 6; (* ECMAScript object: includes objects, arrays, functions, threads *)
  DUK_TYPE_BUFFER    = 7; (* fixed or dynamic, garbage collected byte buffer *)
  DUK_TYPE_POINTER   = 8; (* raw void pointer *)
  DUK_TYPE_LIGHTFUNC = 9; (* lightweight function pointer *)
  DUK_TYPE_MAX       = 9;

(* Value mask types, used by e.g. duk_get_type_mask() *)
const
  DUK_TYPE_MASK_NONE      = 1 shl DUK_TYPE_NONE;
  DUK_TYPE_MASK_UNDEFINED = 1 shl DUK_TYPE_UNDEFINED;
  DUK_TYPE_MASK_NULL      = 1 shl DUK_TYPE_NULL;
  DUK_TYPE_MASK_BOOLEAN   = 1 shl DUK_TYPE_BOOLEAN;
  DUK_TYPE_MASK_NUMBER    = 1 shl DUK_TYPE_NUMBER;
  DUK_TYPE_MASK_STRING    = 1 shl DUK_TYPE_STRING;
  DUK_TYPE_MASK_OBJECT    = 1 shl DUK_TYPE_OBJECT;
  DUK_TYPE_MASK_BUFFER    = 1 shl DUK_TYPE_BUFFER;
  DUK_TYPE_MASK_POINTER   = 1 shl DUK_TYPE_POINTER;
  DUK_TYPE_MASK_LIGHTFUNC = 1 shl DUK_TYPE_LIGHTFUNC;
  DUK_TYPE_MASK_THROW     = 1 shl 10; (* internal flag value: throw if mask doesn't match *)
  DUK_TYPE_MASK_PROMOTE   = 1 shl 11; (* internal flag value: promote to object if mask matches *)

(* Coercion hints *)
const
  DUK_HINT_NONE   = 0; (* prefer number, unless input is a Date, in which
                        * case prefer string (E5 Section 8.12.8) *)
  DUK_HINT_STRING = 1; (* prefer string *)
  DUK_HINT_NUMBER = 2; (* prefer number *)

(* Enumeration flags for duk_enum() *)
const
  DUK_ENUM_INCLUDE_NONENUMERABLE = 1 shl 0; (* enumerate non-numerable properties in addition to enumerable *)
  DUK_ENUM_INCLUDE_HIDDEN        = 1 shl 1; (* enumerate hidden symbols too (in Duktape 1.x called internal properties) *)
  DUK_ENUM_INCLUDE_SYMBOLS       = 1 shl 2; (* enumerate symbols *)
  DUK_ENUM_EXCLUDE_STRINGS       = 1 shl 3; (* exclude strings *)
  DUK_ENUM_OWN_PROPERTIES_ONLY   = 1 shl 4; (* don't walk prototype chain, only check own properties *)
  DUK_ENUM_ARRAY_INDICES_ONLY    = 1 shl 5; (* only enumerate array indices *)
  DUK_ENUM_SORT_ARRAY_INDICES    = 1 shl 6; (* sort array indices (applied to full enumeration result, including inherited array indices) *)
  DUK_ENUM_NO_PROXY_BEHAVIOR     = 1 shl 7; (* enumerate a proxy object itself without invoking proxy behavior *)

(* Compilation flags for duk_compile() and duk_eval() *)
(* DUK_COMPILE_xxx bits 0-2 are reserved for an internal 'nargs' argument.
 *)
const
  DUK_COMPILE_EVAL       = 1 shl 3; (* compile eval code (instead of global code) *)
  DUK_COMPILE_FUNCTION   = 1 shl 4; (* compile function code (instead of global code) *)
  DUK_COMPILE_STRICT     = 1 shl 5; (* use strict (outer) context for global, eval, or function code *)
  DUK_COMPILE_SHEBANG    = 1 shl 6; (* allow shebang ('#! ...') comment on first line of source *)
  DUK_COMPILE_SAFE       = 1 shl 7; (* (internal) catch compilation errors *)
  DUK_COMPILE_NORESULT   = 1 shl 8; (* (internal) omit eval result *)
  DUK_COMPILE_NOSOURCE   = 1 shl 9; (* (internal) no source string on stack *)
  DUK_COMPILE_STRLEN     = 1 shl 10; (* (internal) take strlen() of src_buffer (avoids double evaluation in macro) *)
  DUK_COMPILE_NOFILENAME = 1 shl 11; (* (internal) no filename on stack *)
  DUK_COMPILE_FUNCEXPR   = 1 shl 12; (* (internal) source is a function expression (used for Function constructor) *)

(* Flags for duk_def_prop() and its variants *)
const
  DUK_DEFPROP_WRITABLE           = 1 shl 0; (* set writable (effective if DUK_DEFPROP_HAVE_WRITABLE set) *)
  DUK_DEFPROP_ENUMERABLE         = 1 shl 1; (* set enumerable (effective if DUK_DEFPROP_HAVE_ENUMERABLE set) *)
  DUK_DEFPROP_CONFIGURABLE       = 1 shl 2; (* set configurable (effective if DUK_DEFPROP_HAVE_CONFIGURABLE set) *)
  DUK_DEFPROP_HAVE_WRITABLE      = 1 shl 3; (* set/clear writable *)
  DUK_DEFPROP_HAVE_ENUMERABLE    = 1 shl 4; (* set/clear enumerable *)
  DUK_DEFPROP_HAVE_CONFIGURABLE  = 1 shl 5; (* set/clear configurable *)
  DUK_DEFPROP_HAVE_VALUE         = 1 shl 6; (* set value (given on value stack) *)
  DUK_DEFPROP_HAVE_GETTER        = 1 shl 7; (* set getter (given on value stack) *)
  DUK_DEFPROP_HAVE_SETTER        = 1 shl 8; (* set setter (given on value stack) *)
  DUK_DEFPROP_FORCE              = 1 shl 9; (* force change if possible, may still fail for e.g. virtual properties *)
  DUK_DEFPROP_SET_WRITABLE       = DUK_DEFPROP_HAVE_WRITABLE or DUK_DEFPROP_WRITABLE;
  DUK_DEFPROP_CLEAR_WRITABLE     = DUK_DEFPROP_HAVE_WRITABLE;
  DUK_DEFPROP_SET_ENUMERABLE     = DUK_DEFPROP_HAVE_ENUMERABLE or DUK_DEFPROP_ENUMERABLE;
  DUK_DEFPROP_CLEAR_ENUMERABLE   = DUK_DEFPROP_HAVE_ENUMERABLE;
  DUK_DEFPROP_SET_CONFIGURABLE   = DUK_DEFPROP_HAVE_CONFIGURABLE or DUK_DEFPROP_CONFIGURABLE;
  DUK_DEFPROP_CLEAR_CONFIGURABLE = DUK_DEFPROP_HAVE_CONFIGURABLE;
  DUK_DEFPROP_W                  = DUK_DEFPROP_WRITABLE;
  DUK_DEFPROP_E                  = DUK_DEFPROP_ENUMERABLE;
  DUK_DEFPROP_C                  = DUK_DEFPROP_CONFIGURABLE;
  DUK_DEFPROP_WE                 = DUK_DEFPROP_WRITABLE or DUK_DEFPROP_ENUMERABLE;
  DUK_DEFPROP_WC                 = DUK_DEFPROP_WRITABLE or DUK_DEFPROP_CONFIGURABLE;
  DUK_DEFPROP_WEC                = DUK_DEFPROP_WRITABLE or DUK_DEFPROP_ENUMERABLE or DUK_DEFPROP_CONFIGURABLE;
  DUK_DEFPROP_HAVE_W             = DUK_DEFPROP_HAVE_WRITABLE;
  DUK_DEFPROP_HAVE_E             = DUK_DEFPROP_HAVE_ENUMERABLE;
  DUK_DEFPROP_HAVE_C             = DUK_DEFPROP_HAVE_CONFIGURABLE;
  DUK_DEFPROP_HAVE_WE            = DUK_DEFPROP_HAVE_WRITABLE or DUK_DEFPROP_HAVE_ENUMERABLE;
  DUK_DEFPROP_HAVE_WC            = DUK_DEFPROP_HAVE_WRITABLE or DUK_DEFPROP_HAVE_CONFIGURABLE;
  DUK_DEFPROP_HAVE_WEC           = DUK_DEFPROP_HAVE_WRITABLE or DUK_DEFPROP_HAVE_ENUMERABLE or DUK_DEFPROP_HAVE_CONFIGURABLE;
  DUK_DEFPROP_SET_W              = DUK_DEFPROP_SET_WRITABLE;
  DUK_DEFPROP_SET_E              = DUK_DEFPROP_SET_ENUMERABLE;
  DUK_DEFPROP_SET_C              = DUK_DEFPROP_SET_CONFIGURABLE;
  DUK_DEFPROP_SET_WE             = DUK_DEFPROP_SET_WRITABLE or DUK_DEFPROP_SET_ENUMERABLE;
  DUK_DEFPROP_SET_WC             = DUK_DEFPROP_SET_WRITABLE or DUK_DEFPROP_SET_CONFIGURABLE;
  DUK_DEFPROP_SET_WEC            = DUK_DEFPROP_SET_WRITABLE or DUK_DEFPROP_SET_ENUMERABLE or DUK_DEFPROP_SET_CONFIGURABLE;
  DUK_DEFPROP_CLEAR_W            = DUK_DEFPROP_CLEAR_WRITABLE;
  DUK_DEFPROP_CLEAR_E            = DUK_DEFPROP_CLEAR_ENUMERABLE;
  DUK_DEFPROP_CLEAR_C            = DUK_DEFPROP_CLEAR_CONFIGURABLE;
  DUK_DEFPROP_CLEAR_WE           = DUK_DEFPROP_CLEAR_WRITABLE or DUK_DEFPROP_CLEAR_ENUMERABLE;
  DUK_DEFPROP_CLEAR_WC           = DUK_DEFPROP_CLEAR_WRITABLE or DUK_DEFPROP_CLEAR_CONFIGURABLE;
  DUK_DEFPROP_CLEAR_WEC          = DUK_DEFPROP_CLEAR_WRITABLE or DUK_DEFPROP_CLEAR_ENUMERABLE or DUK_DEFPROP_CLEAR_CONFIGURABLE;
  DUK_DEFPROP_ATTR_W             = DUK_DEFPROP_HAVE_WEC or DUK_DEFPROP_W;
  DUK_DEFPROP_ATTR_E             = DUK_DEFPROP_HAVE_WEC or DUK_DEFPROP_E;
  DUK_DEFPROP_ATTR_C             = DUK_DEFPROP_HAVE_WEC or DUK_DEFPROP_C;
  DUK_DEFPROP_ATTR_WE            = DUK_DEFPROP_HAVE_WEC or DUK_DEFPROP_WE;
  DUK_DEFPROP_ATTR_WC            = DUK_DEFPROP_HAVE_WEC or DUK_DEFPROP_WC;
  DUK_DEFPROP_ATTR_WEC           = DUK_DEFPROP_HAVE_WEC or DUK_DEFPROP_WEC;

(* Flags for duk_push_thread_raw() *)
const
  DUK_THREAD_NEW_GLOBAL_ENV = 1 shl 0; (* create a new global environment *)

(* Flags for duk_gc() *)
const
  DUK_GC_COMPACT = 1 shl 0; (* compact heap objects *)

(* Error codes (must be 8 bits at most, see duk_error.h) *)
const
  DUK_ERR_NONE            = 0; (* no error (e.g. from duk_get_error_code()) *)
  DUK_ERR_ERROR           = 1; (* Error *)
  DUK_ERR_EVAL_ERROR      = 2; (* EvalError *)
  DUK_ERR_RANGE_ERROR     = 3; (* RangeError *)
  DUK_ERR_REFERENCE_ERROR = 4; (* ReferenceError *)
  DUK_ERR_SYNTAX_ERROR    = 5; (* SyntaxError *)
  DUK_ERR_TYPE_ERROR      = 6; (* TypeError *)
  DUK_ERR_URI_ERROR       = 7; (* URIError *)

(* Return codes for C functions (shortcut for throwing an error) *)
const
  DUK_RET_ERROR           = -DUK_ERR_ERROR;
  DUK_RET_EVAL_ERROR      = -DUK_ERR_EVAL_ERROR;
  DUK_RET_RANGE_ERROR     = -DUK_ERR_RANGE_ERROR;
  DUK_RET_REFERENCE_ERROR = -DUK_ERR_REFERENCE_ERROR;
  DUK_RET_SYNTAX_ERROR    = -DUK_ERR_SYNTAX_ERROR;
  DUK_RET_TYPE_ERROR      = -DUK_ERR_TYPE_ERROR;
  DUK_RET_URI_ERROR       = -DUK_ERR_URI_ERROR;

(* Return codes for protected calls (duk_safe_call(), duk_pcall()) *)
const
  DUK_EXEC_SUCCESS = 0;
  DUK_EXEC_ERROR   = 1;

(* Debug levels for DUK_USE_DEBUG_WRITE(). *)
const
  DUK_LEVEL_DEBUG   = 0;
  DUK_LEVEL_DDEBUG  = 1;
  DUK_LEVEL_DDDEBUG = 2;

(*
 *  Macros to create Symbols as C statically constructed strings.
 *
 *  Call e.g. as DUK_HIDDEN_SYMBOL("myProperty") <=> ("\xFF" "myProperty").
 *  Local symbols have a unique suffix, caller should take care to avoid
 *  conflicting with the Duktape internal representation by e.g. prepending
 *  a '!' character: DUK_LOCAL_SYMBOL("myLocal", "!123").
 *
 *  Note that these can only be used for string constants, not dynamically
 *  created strings.
 *)

function DUK_HIDDEN_SYMBOL(const AX: UTF8String): UTF8String; inline;
function DUK_GLOBAL_SYMBOL(const AX: UTF8String): UTF8String; inline;
function DUK_LOCAL_SYMBOL(const AX, AUniq: UTF8String): UTF8String; inline;
function DUK_WELLKNOWN_SYMBOL(const AX: UTF8String): UTF8String; inline;

(*
 *  Context management
 *)

function duk_create_heap(alloc_func: TDukAllocFunction; realloc_func: TDukReallocFunction; free_func: TDukFreeFunction; heap_udata: Pointer; fatal_handler: TDukFatalFunction): PDukContext; cdecl external LIB_DUKTAPE name PREFIX + 'duk_create_heap';
procedure duk_destroy_heap(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_destroy_heap';

procedure duk_suspend(ctx: PDukContext; state: PDukThreadState); cdecl external LIB_DUKTAPE name PREFIX + 'duk_suspend';
procedure duk_resume(ctx: PDukContext; const state: PDukThreadState); cdecl external LIB_DUKTAPE name PREFIX + 'duk_resume';

function duk_create_heap_default: PDukContext; inline;

(*
 *  Memory management
 *
 *  Raw functions have no side effects (cannot trigger GC).
 *)

function duk_alloc_raw(ctx: PDukContext; size: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_alloc_raw';
procedure duk_free_raw(ctx: PDukContext; ptr: Pointer); cdecl external LIB_DUKTAPE name PREFIX + 'duk_free_raw';
function duk_realloc_raw(ctx: PDukContext; ptr: Pointer; size: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_realloc_raw';
function duk_alloc(ctx: PDukContext; size: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_alloc';
procedure duk_free(ctx: PDukContext; ptr: Pointer); cdecl external LIB_DUKTAPE name PREFIX + 'duk_free';
function duk_realloc(ctx: PDukContext; ptr: Pointer; size: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_realloc';
procedure duk_get_memory_functions(ctx: PDukContext; out_funcs: PDukMemoryFunctions); cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_memory_functions';
procedure duk_gc(ctx: PDukContext; flags: TDukUInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_gc';

(*
 *  Error handling
 *)

procedure duk_throw_raw(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_throw_raw';
procedure duk_throw(ctx: PDukContext); inline;

procedure duk_fatal_raw(ctx: PDukContext; const err_msg: MarshaledAString); cdecl external LIB_DUKTAPE name PREFIX + 'duk_fatal_raw';
procedure duk_fatal(ctx: PDukContext; const err_msg: MarshaledAString); inline;

procedure duk_error_raw(ctx: PDukContext; err_code: TDukErrCode; const filename: MarshaledAString; const line: TDukInt; const fmt: MarshaledAString); varargs; cdecl external LIB_DUKTAPE name PREFIX + 'duk_error_raw';
procedure duk_error(ctx: PDukContext; err_code: TDukErrCode; const fmt: MarshaledAString); inline;
procedure duk_generic_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
procedure duk_eval_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
procedure duk_range_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
procedure duk_reference_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
procedure duk_syntax_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
procedure duk_type_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
procedure duk_uri_error(ctx: PDukContext; const fmt: MarshaledAString); inline;

(*
 *  Other state related functions
 *)

function duk_is_strict_call(ctx: PDukContext): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_strict_call';
function duk_is_constructor_call(ctx: PDukContext): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_constructor_call';

(*
 *  Stack management
 *)

function duk_normalize_index(ctx: PDukContext; idx: TDukIdx): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_normalize_index';
function duk_require_normalize_index(ctx: PDukContext; idx: TDukIdx): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_normalize_index';
function duk_is_valid_index(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_valid_index';
procedure duk_require_valid_index(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_valid_index';

function duk_get_top(ctx: PDukContext): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_top';
procedure duk_set_top(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_set_top';
function duk_get_top_index(ctx: PDukContext): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_top_index';
function duk_require_top_index(ctx: PDukContext): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_top_index';

(* Although extra/top could be an unsigned type here, using a signed type
 * makes the API more robust to calling code calculation errors or corner
 * cases (where caller might occasionally come up with negative values).
 * Negative values are treated as zero, which is better than casting them
 * to a large unsigned number.  (This principle is used elsewhere in the
 * API too.)
 *)
function duk_check_stack(ctx: PDukContext; extra: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_check_stack';
procedure duk_require_stack(ctx: PDukContext; extra: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_stack';
function duk_check_stack_top(ctx: PDukContext; top: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_check_stack_top';
procedure duk_require_stack_top(ctx: PDukContext; top: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_stack_top';

(*
 *  Stack manipulation (other than push/pop)
 *)

procedure duk_swap(ctx: PDukContext; idx1: TDukIdx; idx2: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_swap';
procedure duk_swap_top(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_swap_top';
procedure duk_dup(ctx: PDukContext; from_idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_dup';
procedure duk_dup_top(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_dup_top';
procedure duk_insert(ctx: PDukContext; to_idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_insert';
procedure duk_replace(ctx: PDukContext; to_idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_replace';
procedure duk_copy(ctx: PDukContext; from_idx: TDukIdx; to_idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_copy';
procedure duk_remove(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_remove';
procedure duk_xcopymove_raw(to_ctx: PDukContext; from_ctx: PDukContext; count: TDukIdx; is_copy: TDukBool); cdecl external LIB_DUKTAPE name PREFIX + 'duk_xcopymove_raw';

procedure duk_xmove_top(to_ctx: PDukContext; from_ctx: PDukContext; count: TDukIdx); inline;
procedure duk_xcopy_top(to_ctx: PDukContext; from_ctx: PDukContext; count: TDukIdx); inline;

(*
 *  Push operations
 *
 *  Push functions return the absolute (relative to bottom of frame)
 *  position of the pushed value for convenience.
 *
 *  Note: duk_dup() is technically a push.
 *)

procedure duk_push_undefined(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_undefined';
procedure duk_push_null(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_null';
procedure duk_push_boolean(ctx: PDukContext; val: TDukBool); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_boolean';
procedure duk_push_true(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_true';
procedure duk_push_false(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_false';
procedure duk_push_number(ctx: PDukContext; val: TDukDouble); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_number';
procedure duk_push_nan(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_nan';
procedure duk_push_int(ctx: PDukContext; val: TDukInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_int';
procedure duk_push_uint(ctx: PDukContext; val: TDukUInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_uint';
function duk_push_string(ctx: PDukContext; const str: MarshaledAString): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_string';
function duk_push_lstring(ctx: PDukContext; const str: MarshaledAString; len: TDukSize): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_lstring';
procedure duk_push_pointer(ctx: PDukContext; p: Pointer); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_pointer';
function duk_push_sprintf(ctx: PDukContext; const fmt: MarshaledAString): MarshaledAString; cdecl; varargs external LIB_DUKTAPE name PREFIX + 'duk_push_sprintf';

function duk_push_literal(ctx: PDukContext; const str: MarshaledAString): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_string';

procedure duk_push_this(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_this';
procedure duk_push_new_target(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_new_target';
procedure duk_push_current_function(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_current_function';
procedure duk_push_current_thread(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_current_thread';
procedure duk_push_global_object(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_global_object';
procedure duk_push_heap_stash(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_heap_stash';
procedure duk_push_global_stash(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_global_stash';
procedure duk_push_thread_stash(ctx: PDukContext; target_ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_thread_stash';

function duk_push_object(ctx: PDukContext): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_object';
function duk_push_bare_object(ctx: PDukContext): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_bare_object';
function duk_push_array(ctx: PDukContext): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_array';
function duk_push_c_function(ctx: PDukContext; func: TDukCFunction; nargs: TDukIdx): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_c_function';
function duk_push_c_lightfunc(ctx: PDukContext; func: TDukCFunction; nargs: TDukIdx; length: TDukIdx; magic: TDukInt): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_c_lightfunc';
function duk_push_thread_raw(ctx: PDukContext; flags: TDukUInt): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_thread_raw';
function duk_push_proxy(ctx: PDukContext; proxy_flags: TDukUInt): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_proxy';

function duk_push_thread(ctx: PDukContext): TDukIdx; inline;
function duk_push_thread_new_globalenv(ctx: PDukContext): TDukIdx; inline;

function duk_push_error_object_raw(ctx: PDukContext; err_code: TDukErrcode; const filename: MarshaledAString; line: TDukInt; const fmt: MarshaledAString): TDukIdx; cdecl; varargs external LIB_DUKTAPE name PREFIX + 'duk_push_error_object_raw';
function duk_push_error_object(ctx: PDukContext; err_code: TDukErrcode; const fmt: MarshaledAString): TDukIdx; inline;

const
  DUK_BUF_FLAG_DYNAMIC  = 1 shl 0; (* internal flag: dynamic buffer *)
  DUK_BUF_FLAG_EXTERNAL = 1 shl 1; (* internal flag: external buffer *)
  DUK_BUF_FLAG_NOZERO   = 1 shl 2; (* internal flag: don't zero allocated buffer *)

function duk_push_buffer_raw(ctx: PDukContext; size: TDukSize; flags: TDukSmallUInt): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_buffer_raw';
function duk_push_buffer(ctx: PDukContext; size: TDukSize; dynamic: Boolean): Pointer; inline;
function duk_push_fixed_buffer(ctx: PDukContext; size: TDukSize): Pointer; inline;
function duk_push_dynamic_buffer(ctx: PDukContext; size: TDukSize): Pointer; inline;
function duk_push_external_buffer(ctx: PDukContext): Pointer; inline;

const
  DUK_BUFOBJ_ARRAYBUFFER       = 0;
  DUK_BUFOBJ_NODEJS_BUFFER     = 1;
  DUK_BUFOBJ_DATAVIEW          = 2;
  DUK_BUFOBJ_INT8ARRAY         = 3;
  DUK_BUFOBJ_UINT8ARRAY        = 4;
  DUK_BUFOBJ_UINT8CLAMPEDARRAY = 5;
  DUK_BUFOBJ_INT16ARRAY        = 6;
  DUK_BUFOBJ_UINT16ARRAY       = 7;
  DUK_BUFOBJ_INT32ARRAY        = 8;
  DUK_BUFOBJ_UINT32ARRAY       = 9;
  DUK_BUFOBJ_FLOAT32ARRAY      = 10;
  DUK_BUFOBJ_FLOAT64ARRAY      = 11;

procedure duk_push_buffer_object(ctx: PDukContext; idx_buffer: TDukIdx; byte_offset: TDukSize; byte_length: TDukSize; flags: TDukUInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_buffer_object';

function duk_push_heapptr(ctx: PDukContext; ptr: Pointer): TDukIdx; cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_heapptr';

(*
 *  Pop operations
 *)

procedure duk_pop(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_pop';
procedure duk_pop_n(ctx: PDukContext; count: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_pop_n';
procedure duk_pop_2(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_pop_2';
procedure duk_pop_3(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_pop_3';

(*
 *  Type checks
 *
 *  duk_is_none(), which would indicate whether index it outside of stack,
 *  is not needed; duk_is_valid_index() gives the same information.
 *)

function duk_get_type(ctx: PDukContext; idx: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_type';
function duk_check_type(ctx: PDukContext; idx: TDukIdx; _type: TDukInt): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_check_type';
function duk_get_type_mask(ctx: PDukContext; idx: TDukIdx): TDukUInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_type_mask';
function duk_check_type_mask(ctx: PDukContext; idx: TDukIdx; mask: TDukUInt): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_check_type_mask';

function duk_is_undefined(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_undefined';
function duk_is_null(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_null';
function duk_is_null_or_undefined(ctx: PDukContext; idx: TDukIdx): TDukBool; inline;

function duk_is_boolean(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_boolean';
function duk_is_number(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_number';
function duk_is_nan(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_nan';
function duk_is_string(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_string';
function duk_is_object(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_object';
function duk_is_buffer(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_buffer';
function duk_is_buffer_data(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_buffer_data';
function duk_is_pointer(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_pointer';
function duk_is_lightfunc(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_lightfunc';

function duk_is_symbol(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_symbol';
function duk_is_array(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_array';
function duk_is_function(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_function';
function duk_is_c_function(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_c_function';
function duk_is_ecmascript_function(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_ecmascript_function';
function duk_is_bound_function(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_bound_function';
function duk_is_thread(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_thread';
function duk_is_callable(ctx: PDukContext; idx: TDukIdx): TDukBool; inline;
function duk_is_constructable(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_constructable';

function duk_is_dynamic_buffer(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_dynamic_buffer';
function duk_is_fixed_buffer(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_fixed_buffer';
function duk_is_external_buffer(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_is_external_buffer';

(* Buffers and lightfuncs are not considered primitive because they mimic
 * objects and e.g. duk_to_primitive() will coerce them instead of returning
 * them as is.  Symbols are represented as strings internally.
 *)
function duk_is_primitive(ctx: PDukContext; idx: TDukIdx): TDukBool; inline;

(* Symbols are object coercible, covered by DUK_TYPE_MASK_STRING. *)
function duk_is_object_coercible(ctx: PDukContext; idx: TDukIdx): TDukBool; inline;

function duk_get_error_code(ctx: PDukContext; idx: TDukIdx): TDukErrcode; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_error_code';
function duk_is_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
function duk_is_eval_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
function duk_is_range_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
function duk_is_reference_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
function duk_is_syntax_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
function duk_is_type_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
function duk_is_uri_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;

(*
 *  Get operations: no coercion, returns default value for invalid
 *  indices and invalid value types.
 *
 *  duk_get_undefined() and duk_get_null() would be pointless and
 *  are not included.
 *)

function duk_get_boolean(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_boolean';
function duk_get_number(ctx: PDukContext; idx: TDukIdx): TDukDouble; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_number';
function duk_get_int(ctx: PDukContext; idx: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_int';
function duk_get_uint(ctx: PDukContext; idx: TDukIdx): TDukUInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_uint';
function duk_get_string(ctx: PDukContext; idx: TDukIdx): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_string';
function duk_get_lstring(ctx: PDukContext; idx: TDukIdx; out_len: PDukSize): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_lstring';
function duk_get_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_buffer';
function duk_get_buffer_data(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_buffer_data';
function duk_get_pointer(ctx: PDukContext; idx: TDukIdx): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_pointer';
function duk_get_c_function(ctx: PDukContext; idx: TDukIdx): TDukCFunction; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_c_function';
function duk_get_context(ctx: PDukContext; idx: TDukIdx): PDukContext; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_context';
function duk_get_heapptr(ctx: PDukContext; idx: TDukIdx): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_heapptr';

(*
 *  Get-with-explicit default operations: like get operations but with an
 *  explicit default value.
 *)

function duk_get_boolean_default(ctx: PDukContext; idx: TDukIdx; def_value: TDukBool): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_boolean_default';
function duk_get_number_default(ctx: PDukContext; idx: TDukIdx; def_value: TDukDouble): TDukDouble; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_number_default';
function duk_get_int_default(ctx: PDukContext; idx: TDukIdx; def_value: TDukInt): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_int_default';
function duk_get_uint_default(ctx: PDukContext; idx: TDukIdx; def_value: TDukUInt): TDukUInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_uint_default';
function duk_get_string_default(ctx: PDukContext; idx: TDukIdx; const def_value: MarshaledAString): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_string_default';
function duk_get_lstring_default(ctx: PDukContext; idx: TDukIdx; out_len: PDukSize; const def_ptr: MarshaledAString; def_len: TDukSize): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_lstring_default';
function duk_get_buffer_default(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize; def_ptr: Pointer; def_len: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_buffer_default';
function duk_get_buffer_data_default(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize; def_ptr: Pointer; def_len: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_buffer_data_default';
function duk_get_pointer_default(ctx: PDukContext; idx: TDukIdx; def_value: Pointer): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_pointer_default';
function duk_get_c_function_default(ctx: PDukContext; idx: TDukIdx; def_value: TDukCFunction): TDukCFunction; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_c_function_default';
function duk_get_context_default(ctx: PDukContext; idx: TDukIdx; def_value: PDukContext): PDukContext; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_context_default';
function duk_get_heapptr_default(ctx: PDukContext; idx: TDukIdx; def_value: Pointer): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_heapptr_default';

(*
 *  Opt operations: like require operations but with an explicit default value
 *  when value is undefined or index is invalid, null and non-matching types
 *  cause a TypeError.
 *)

function duk_opt_boolean(ctx: PDukContext; idx: TDukIdx; def_value: TDukBool): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_boolean';
function duk_opt_number(ctx: PDukContext; idx: TDukIdx; def_value: TDukDouble): TDukDouble; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_number';
function duk_opt_int(ctx: PDukContext; idx: TDukIdx; def_value: TDukInt): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_int';
function duk_opt_uint(ctx: PDukContext; idx: TDukIdx; def_value: TDukUInt): TDukUInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_uint';
function duk_opt_string(ctx: PDukContext; idx: TDukIdx; const def_ptr: MarshaledAString): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_string';
function duk_opt_lstring(ctx: PDukContext; idx: TDukIdx; out_len: PDukSize; const def_ptr: MarshaledAString; def_len: TDukSize): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_lstring';
function duk_opt_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize; def_ptr: Pointer; def_size: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_buffer';
function duk_opt_buffer_data(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize; def_ptr: Pointer; def_size: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_buffer_data';
function duk_opt_pointer(ctx: PDukContext; idx: TDukIdx; def_value: Pointer): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_pointer';
function duk_opt_c_function(ctx: PDukContext; idx: TDukIdx; def_value: TDukCFunction): TDukCFunction; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_c_function';
function duk_opt_context(ctx: PDukContext; idx: TDukIdx; def_value: PDukContext): PDukContext; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_context';
function duk_opt_heapptr(ctx: PDukContext; idx: TDukIdx; def_value: Pointer): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_opt_heapptr';

(*
 *  Require operations: no coercion, throw error if index or type
 *  is incorrect.  No defaulting.
 *)

procedure duk_require_type_mask(ctx: PDukContext; idx: TDukIdx; mask: TDukUInt); inline;

procedure duk_require_undefined(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_undefined';
procedure duk_require_null(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_null';
function duk_require_boolean(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_boolean';
function duk_require_number(ctx: PDukContext; idx: TDukIdx): TDukDouble; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_number';
function duk_require_int(ctx: PDukContext; idx: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_int';
function duk_require_uint(ctx: PDukContext; idx: TDukIdx): TDukUInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_uint';
function duk_require_string(ctx: PDukContext; idx: TDukIdx): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_string';
function duk_require_lstring(ctx: PDukContext; idx: TDukIdx; out_len: PDukSize): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_lstring';
procedure duk_require_object(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_object';
function duk_require_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_buffer';
function duk_require_buffer_data(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_buffer_data';
function duk_require_pointer(ctx: PDukContext; idx: TDukIdx): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_pointer';
function duk_require_c_function(ctx: PDukContext; idx: TDukIdx): TDukCFunction; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_c_function';
function duk_require_context(ctx: PDukContext; idx: TDukIdx): PDukContext; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_context';
procedure duk_require_function(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_function';
procedure duk_require_callable(ctx: PDukContext; idx: TDukIdx); inline;
function duk_require_heapptr(ctx: PDukContext; idx: TDukIdx): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_require_heapptr';

(* Symbols are object coercible and covered by DUK_TYPE_MASK_STRING. *)
procedure duk_require_object_coercible(ctx: PDukContext; idx: TDukIdx); inline;

(*
 *  Coercion operations: in-place coercion, return coerced value where
 *  applicable.  If index is invalid, throw error.  Some coercions may
 *  throw an expected error (e.g. from a toString() or valueOf() call)
 *  or an internal error (e.g. from out of memory).
 *)

procedure duk_to_undefined(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_undefined';
procedure duk_to_null(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_null';
function duk_to_boolean(ctx: PDukContext; idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_boolean';
function duk_to_number(ctx: PDukContext; idx: TDukIdx): TDukDouble; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_number';
function duk_to_int(ctx: PDukContext; idx: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_int';
function duk_to_uint(ctx: PDukContext; idx: TDukIdx): TDukUInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_uint';
function duk_to_int32(ctx: PDukContext; idx: TDukIdx): TDukInt32; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_int32';
function duk_to_uint32(ctx: PDukContext; idx: TDukIdx): TDukUInt32; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_uint32';
function duk_to_uint16(ctx: PDukContext; idx: TDukIdx): TDukUInt16; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_uint16';
function duk_to_string(ctx: PDukContext; idx: TDukIdx): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_string';
function duk_to_lstring(ctx: PDukContext; idx: TDukIdx; out_len: PDukSize): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_lstring';
function duk_to_buffer_raw(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize; flags: TDukUInt): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_buffer_raw';
function duk_to_pointer(ctx: PDukContext; idx: TDukIdx): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_pointer';
procedure duk_to_object(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_object';
procedure duk_to_primitive(ctx: PDukContext; idx: TDukIdx; hint: TDukInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_to_primitive';

const
  DUK_BUF_MODE_FIXED    = 0; (* internal: request fixed buffer result *)
  DUK_BUF_MODE_DYNAMIC  = 1; (* internal: request dynamic buffer result *)
  DUK_BUF_MODE_DONTCARE = 2; (* internal: don't care about fixed/dynamic nature *)

function duk_to_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; inline;
function duk_to_fixed_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; inline;
function duk_to_dynamic_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; inline;

(* safe variants of a few coercion operations *)
function duk_safe_to_lstring(ctx: PDukContext; idx: TDukIdx; out_len: PDukSize): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_safe_to_lstring';
function duk_safe_to_string(ctx: PDukContext; idx: TDukIdx): MarshaledAString; inline;

(*
 *  Value length
 *)

function duk_get_length(ctx: PDukContext; idx: TDukIdx): TDukSize; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_length';
procedure duk_set_length(ctx: PDukContext; idx: TDukIdx; len: TDukSize); cdecl external LIB_DUKTAPE name PREFIX + 'duk_set_length';

(*
 *  Misc conversion
 *)

function duk_base64_encode(ctx: PDukContext; idx: TDukIdx): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_base64_encode';
procedure duk_base64_decode(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_base64_decode';
function duk_hex_encode(ctx: PDukContext; idx: TDukIdx): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_hex_encode';
procedure duk_hex_decode(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_hex_decode';
function duk_json_encode(ctx: PDukContext; idx: TDukIdx): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_json_encode';
procedure duk_json_decode(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_json_decode';

function duk_buffer_to_string(ctx: PDukContext; idx: TDukIdx): MarshaledAString; cdecl external LIB_DUKTAPE name PREFIX + 'duk_buffer_to_string';

(*
 *  Buffer
 *)

function duk_resize_buffer(ctx: PDukContext; idx: TDukIdx; new_size: TDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_resize_buffer';
function duk_steal_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; cdecl external LIB_DUKTAPE name PREFIX + 'duk_steal_buffer';
procedure duk_config_buffer(ctx: PDukContext; idx: TDukIdx; ptr: Pointer; len: TDukSize); cdecl external LIB_DUKTAPE name PREFIX + 'duk_config_buffer';

(*
 *  Property access
 *
 *  The basic function assumes key is on stack.  The _(l)string variant takes
 *  a C string as a property name; the _literal variant takes a C literal.
 *  The _index variant takes an array index as a property name (e.g. 123 is
 *  equivalent to the key "123").  The _heapptr variant takes a raw, borrowed
 *  heap pointer.
 *)

function duk_get_prop(ctx: PDukContext; obj_idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_prop';
function duk_get_prop_string(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_prop_string';
function duk_get_prop_literal(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_prop_string';
function duk_get_prop_lstring(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString; key_len: TDukSize): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_prop_lstring';
function duk_get_prop_index(ctx: PDukContext; obj_idx: TDukIdx; arr_idx: TDukUArrIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_prop_index';
function duk_get_prop_heapptr(ctx: PDukContext; obj_idx: TDukIdx; ptr: Pointer): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_prop_heapptr';
function duk_put_prop(ctx: PDukContext; obj_idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_prop';
function duk_put_prop_string(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_prop_string';
function duk_put_prop_literal(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_prop_string';
function duk_put_prop_lstring(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString; key_len: TDukSize): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_prop_lstring';
function duk_put_prop_index(ctx: PDukContext; obj_idx: TDukIdx; arr_idx: TDukUArrIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_prop_index';
function duk_put_prop_heapptr(ctx: PDukContext; obj_idx: TDukIdx; ptr: Pointer): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_prop_heapptr';
function duk_del_prop(ctx: PDukContext; obj_idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_del_prop';
function duk_del_prop_string(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_del_prop_string';
function duk_del_prop_literal(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_del_prop_string';
function duk_del_prop_lstring(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString; key_len: TDukSize): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_del_prop_lstring';
function duk_del_prop_index(ctx: PDukContext; obj_idx: TDukIdx; arr_idx: TDukUArrIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_del_prop_index';
function duk_del_prop_heapptr(ctx: PDukContext; obj_idx: TDukIdx; ptr: Pointer): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_del_prop_heapptr';
function duk_has_prop(ctx: PDukContext; obj_idx: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_has_prop';
function duk_has_prop_string(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_has_prop_string';
function duk_has_prop_literal(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_has_prop_string';
function duk_has_prop_lstring(ctx: PDukContext; obj_idx: TDukIdx; const key: MarshaledAString; key_len: TDukSize): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_has_prop_lstring';
function duk_has_prop_index(ctx: PDukContext; obj_idx: TDukIdx; arr_idx: TDukUArrIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_has_prop_index';
function duk_has_prop_heapptr(ctx: PDukContext; obj_idx: TDukIdx; ptr: Pointer): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_has_prop_heapptr';

procedure duk_get_prop_desc(ctx: PDukContext; obj_idx: TDukIdx; flags: TDukUInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_prop_desc';
procedure duk_def_prop(ctx: PDukContext; obj_idx: TDukIdx; flags: TDukUInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_def_prop';

function duk_get_global_string(ctx: PDukContext; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_global_string';
function duk_get_global_literal(ctx: PDukContext; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_global_string';
function duk_get_global_heapptr(ctx: PDukContext; const ptr: Pointer): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_global_heapptr';
function duk_get_global_lstring(ctx: PDukContext; const key: MarshaledAString; key_len: TDukSize): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_global_lstring';
function duk_put_global_string(ctx: PDukContext; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_global_string';
function duk_put_global_literal(ctx: PDukContext; const key: MarshaledAString): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_global_string';
function duk_put_global_lstring(ctx: PDukContext; const key: MarshaledAString; key_len: TDukSize): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_global_lstring';
function duk_put_global_heapptr(ctx: PDukContext; const ptr: Pointer): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_global_heapptr';

(*
 *  Inspection
 *)

procedure duk_inspect_value(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_inspect_value';
procedure duk_inspect_callstack_entry(ctx: PDukContext; level: TDukInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_inspect_callstack_entry';

(*
 *  Object prototype
 *)

procedure duk_get_prototype(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_prototype';
procedure duk_set_prototype(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_set_prototype';

(*
 *  Object finalizer
 *)

procedure duk_get_finalizer(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_finalizer';
procedure duk_set_finalizer(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_set_finalizer';

(*
 *  Global object
 *)

procedure duk_set_global_object(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_set_global_object';

(*
 *  Duktape/C function magic value
 *)

function duk_get_magic(ctx: PDukContext; idx: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_magic';
procedure duk_set_magic(ctx: PDukContext; idx: TDukIdx; magic: TDukInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_set_magic';
function duk_get_current_magic(ctx: PDukContext): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_current_magic';

(*
 *  Module helpers: put multiple function or constant properties
 *)

procedure duk_put_function_list(ctx: PDukContext; obj_idx: TDukIdx; const funcs: PDukFunctionListEntry); cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_function_list';
procedure duk_put_number_list(ctx: PDukContext; obj_idx: TDukIdx; const numbers: PDukNumberListEntry); cdecl external LIB_DUKTAPE name PREFIX + 'duk_put_number_list';

(*
 *  Object operations
 *)

procedure duk_compact(ctx: PDukContext; obj_idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_compact';
procedure duk_enum(ctx: PDukContext; obj_idx: TDukIdx; enum_flags: TDukUInt); cdecl external LIB_DUKTAPE name PREFIX + 'duk_enum';
function duk_next(ctx: PDukContext; enum_idx: TDukIdx; get_value: TDukBool): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_next';
procedure duk_seal(ctx: PDukContext; obj_idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_seal';
procedure duk_freeze(ctx: PDukContext; obj_idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_freeze';

(*
 *  String manipulation
 *)

procedure duk_concat(ctx: PDukContext; count: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_concat';
procedure duk_join(ctx: PDukContext; count: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_join';
procedure duk_decode_string(ctx: PDukContext; idx: TDukIdx; callback: TDukDecodeCharFunction; udata: Pointer); cdecl external LIB_DUKTAPE name PREFIX + 'duk_decode_string';
procedure duk_map_string(ctx: PDukContext; idx: TDukIdx; callback: TDukMapCharFunction; udata: Pointer); cdecl external LIB_DUKTAPE name PREFIX + 'duk_map_string';
procedure duk_substring(ctx: PDukContext; idx: TDukIdx; start_char_offset: TDukSize; end_char_offset: TDukSize); cdecl external LIB_DUKTAPE name PREFIX + 'duk_substring';
procedure duk_trim(ctx: PDukContext; idx: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_trim';
function duk_char_code_at(ctx: PDukContext; idx: TDukIdx; char_offset: TDukSize): TDukCodepoint; cdecl external LIB_DUKTAPE name PREFIX + 'duk_char_code_at';

(*
 *  ECMAScript operators
 *)

function duk_equals(ctx: PDukContext; idx1: TDukIdx; idx2: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_equals';
function duk_strict_equals(ctx: PDukContext; idx1: TDukIdx; idx2: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_strict_equals';
function duk_samevalue(ctx: PDukContext; idx1: TDukIdx; idx2: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_samevalue';
function duk_instanceof(ctx: PDukContext; idx1: TDukIdx; idx2: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_instanceof';

(*
 *  Random
 *)
function duk_random(ctx: PDukContext): TDukDouble; cdecl external LIB_DUKTAPE name PREFIX + 'duk_random';

(*
 *  Function (method) calls
 *)

procedure duk_call(ctx: PDukContext; nargs: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_call';
procedure duk_call_method(ctx: PDukContext; nargs: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_call_method';
procedure duk_call_prop(ctx: PDukContext; obj_idx: TDukIdx; nargs: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_call_prop';
function duk_pcall(ctx: PDukContext; nargs: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_pcall';
function duk_pcall_method(ctx: PDukContext; nargs: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_pcall_method';
function duk_pcall_prop(ctx: PDukContext; obj_idx: TDukIdx; nargs: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_pcall_prop';
procedure duk_new(ctx: PDukContext; nargs: TDukIdx); cdecl external LIB_DUKTAPE name PREFIX + 'duk_new';
function duk_pnew(ctx: PDukContext; nargs: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_pnew';
function duk_safe_call(ctx: PDukContext; func: TDukSafeCallFunction; udata: Pointer; nargs: TDukIdx; nrets: TDukIdx): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_safe_call';

(*
 *  Thread management
 *)

(* There are currently no native functions to yield/resume, due to the internal
 * limitations on coroutine handling.  These will be added later.
 *)

(*
 *  Compilation and evaluation
 *)

function duk_eval_raw(ctx: PDukContext; const src_buffer: MarshaledAString; src_length: TDukSize; flags: TDukUInt): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_eval_raw';
function duk_compile_raw(ctx: PDukContext; const src_buffer: MarshaledAString; src_length: TDukSize; flags: TDukUInt): TDukInt; cdecl external LIB_DUKTAPE name PREFIX + 'duk_compile_raw';

(* plain *)
function duk_eval(ctx: PDukContext): TDukInt; inline;
function duk_eval_noresult(ctx: PDukContext): TDukInt; inline;
function duk_peval(ctx: PDukContext): TDukInt; inline;
function duk_peval_noresult(ctx: PDukContext): TDukInt; inline;
function duk_compile(ctx: PDukContext; flags: TDukUInt): TDukInt; inline;
function duk_pcompile(ctx: PDukContext; flags: TDukUInt): TDukInt; inline;

(* string *)
function duk_eval_string(ctx: PDukContext; const src: MarshaledAString): TDukInt; inline;
function duk_eval_string_noresult(ctx: PDukContext; const src: MarshaledAString): TDukInt; inline;
function duk_peval_string(ctx: PDukContext; const src: MarshaledAString): TDukInt; inline;
function duk_peval_string_noresult(ctx: PDukContext; const src: MarshaledAString): TDukInt; inline;
function duk_compile_string(ctx: PDukContext; flags: TDukUInt; const src: MarshaledAString): TDukInt; inline;
function duk_compile_string_filename(ctx: PDukContext; flags: TDukUInt; const src: MarshaledAString): TDukInt; inline;
function duk_pcompile_string(ctx: PDukContext; flags: TDukUInt; const src: MarshaledAString): TDukInt; inline;
function duk_pcompile_string_filename(ctx: PDukContext; flags: TDukUInt; const src: MarshaledAString): TDukInt; inline;

(* lstring *)
function duk_eval_lstring(ctx: PDukContext; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
function duk_eval_lstring_noresult(ctx: PDukContext; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
function duk_peval_lstring(ctx: PDukContext; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
function duk_peval_lstring_noresult(ctx: PDukContext; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
function duk_compile_lstring(ctx: PDukContext; flags: TDukUInt; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
function duk_compile_lstring_filename(ctx: PDukContext; flags: TDukUInt; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
function duk_pcompile_lstring(ctx: PDukContext; flags: TDukUInt; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
function duk_pcompile_lstring_filename(ctx: PDukContext; flags: TDukUInt; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;

(*
 *  Bytecode load/dump
 *)

procedure duk_dump_function(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_dump_function';
procedure duk_load_function(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_load_function';

(*
 *  Debugging
 *)

procedure duk_push_context_dump(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_push_context_dump';

(*
 *  Debugger (debug protocol)
 *)

procedure duk_debugger_attach(ctx: PDukContext; read_cb: TDukDebugReadFunction; write_cb: TDukDebugWriteFunction; peek_cb: TDukDebugPeekFunction; read_flush_cb: TDukDebugReadFlushFunction; write_flush_cb: TDukDebugWriteFlushFunction; request_cb: TDukDebugRequestFunction; detached_cb: TDukDebugDetachedFunction; udata: Pointer); cdecl external LIB_DUKTAPE name PREFIX + 'duk_debugger_attach';
procedure duk_debugger_detach(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_debugger_detach';
procedure duk_debugger_cooperate(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_debugger_cooperate';
function duk_debugger_notify(ctx: PDukContext; nvalues: TDukIdx): TDukBool; cdecl external LIB_DUKTAPE name PREFIX + 'duk_debugger_notify';
procedure duk_debugger_pause(ctx: PDukContext); cdecl external LIB_DUKTAPE name PREFIX + 'duk_debugger_pause';

(*
 *  Time handling
 *)

function duk_get_now(ctx: PDukContext): TDukDouble; cdecl external LIB_DUKTAPE name PREFIX + 'duk_get_now';
procedure duk_time_to_components(ctx: PDukContext; timeval: TDukDouble; comp: PDukTimeComponents); cdecl external LIB_DUKTAPE name PREFIX + 'duk_time_to_components';
function duk_components_to_time(ctx: PDukContext; comp: PDukTimeComponents): TDukDouble; cdecl external LIB_DUKTAPE name PREFIX + 'duk_components_to_time';

(*
 *  Date provider related constants
 *
 *  NOTE: These are "semi public" - you should only use these if you write
 *  your own platform specific Date provider, see doc/datetime.rst.
 *)

(* Millisecond count constants. *)
const
  DUK_DATE_MSEC_SECOND = 1000;
  DUK_DATE_MSEC_MINUTE = 60 * 1000;
  DUK_DATE_MSEC_HOUR   = 60 * 60 * 1000;
  DUK_DATE_MSEC_DAY    = 24 * 60 * 60 * 1000;

(* ECMAScript date range is 100 million days from Epoch:
 * > 100e6 * 24 * 60 * 60 * 1000  // 100M days in millisecs
 * 8640000000000000
 * (= 8.64e15)
 *)
const
  DUK_DATE_MSEC_100M_DAYS        = 8.64e15;
  DUK_DATE_MSEC_100M_DAYS_LEEWAY = 8.64e15 + 24 * 3600e3;

(* ECMAScript year range:
 * > new Date(100e6 * 24 * 3600e3).toISOString()
 * '+275760-09-13T00:00:00.000Z'
 * > new Date(-100e6 * 24 * 3600e3).toISOString()
 * '-271821-04-20T00:00:00.000Z'
 *)
const
  DUK_DATE_MIN_ECMA_YEAR = -271821;
  DUK_DATE_MAX_ECMA_YEAR =  275760;

(* Part indices for internal breakdowns.  Part order from DUK_DATE_IDX_YEAR
 * to DUK_DATE_IDX_MILLISECOND matches argument ordering of ECMAScript API
 * calls (like Date constructor call).  Some functions in duk_bi_date.c
 * depend on the specific ordering, so change with care.  16 bits are not
 * enough for all parts (year, specifically).
 *
 * Must be in-sync with genbuiltins.py.
 *)
const
  DUK_DATE_IDX_YEAR        = 0; (* year *)
  DUK_DATE_IDX_MONTH       = 1; (* month: 0 to 11 *)
  DUK_DATE_IDX_DAY         = 2; (* day within month: 0 to 30 *)
  DUK_DATE_IDX_HOUR        = 3;
  DUK_DATE_IDX_MINUTE      = 4;
  DUK_DATE_IDX_SECOND      = 5;
  DUK_DATE_IDX_MILLISECOND = 6;
  DUK_DATE_IDX_WEEKDAY     = 7; (* weekday: 0 to 6, 0=sunday, 1=monday, etc *)
  DUK_DATE_IDX_NUM_PARTS   = 8;

(* Internal API call flags, used for various functions in duk_bi_date.c.
 * Certain flags are used by only certain functions, but since the flags
 * don't overlap, a single flags value can be passed around to multiple
 * functions.
 *
 * The unused top bits of the flags field are also used to pass values
 * to helpers (duk__get_part_helper() and duk__set_part_helper()).
 *
 * Must be in-sync with genbuiltins.py.
 *)

(* NOTE: when writing a Date provider you only need a few specific
 * flags from here, the rest are internal.  Avoid using anything you
 * don't need.
 *)
const
  DUK_DATE_FLAG_NAN_TO_ZERO        = 1 shl 0; (* timeval breakdown: internal time value NaN -> zero *)
  DUK_DATE_FLAG_NAN_TO_RANGE_ERROR = 1 shl 1; (* timeval breakdown: internal time value NaN -> RangeError (toISOString) *)
  DUK_DATE_FLAG_ONEBASED           = 1 shl 2; (* timeval breakdown: convert month and day-of-month parts to one-based (default is zero-based) *)
  DUK_DATE_FLAG_EQUIVYEAR          = 1 shl 3; (* timeval breakdown: replace year with equivalent year in the [1971,2037] range for DST calculations *)
  DUK_DATE_FLAG_LOCALTIME          = 1 shl 4; (* convert time value to local time *)
  DUK_DATE_FLAG_SUB1900            = 1 shl 5; (* getter: subtract 1900 from year when getting year part *)
  DUK_DATE_FLAG_TOSTRING_DATE      = 1 shl 6; (* include date part in string conversion result *)
  DUK_DATE_FLAG_TOSTRING_TIME      = 1 shl 7; (* include time part in string conversion result *)
  DUK_DATE_FLAG_TOSTRING_LOCALE    = 1 shl 8; (* use locale specific formatting if available *)
  DUK_DATE_FLAG_TIMESETTER         = 1 shl 9; (* setter: call is a time setter (affects hour, min, sec, ms); otherwise date setter (affects year, month, day-in-month) *)
  DUK_DATE_FLAG_YEAR_FIXUP         = 1 shl 10; (* setter: perform 2-digit year fixup (00...99 -> 1900...1999) *)
  DUK_DATE_FLAG_SEP_T              = 1 shl 11; (* string conversion: use 'T' instead of ' ' as a separator *)
  DUK_DATE_FLAG_VALUE_SHIFT        = 12; (* additional values begin at bit 12 *)

(*
 *  END PUBLIC API
 *)

implementation

function DUK_HIDDEN_SYMBOL(const AX: UTF8String): UTF8String; inline;
begin
  Result := #$FF + AX;
end;

function DUK_GLOBAL_SYMBOL(const AX: UTF8String): UTF8String; inline;
begin
  Result := #$80 + AX;
end;

function DUK_LOCAL_SYMBOL(const AX, AUniq: UTF8String): UTF8String; inline;
begin
  Result := #$81 + AX + #$FF + AUniq;
end;

function DUK_WELLKNOWN_SYMBOL(const AX: UTF8String): UTF8String; inline;
begin
  Result := #$81 + AX + #$FF;
end;

function duk_create_heap_default: PDukContext; inline;
begin
  Result := duk_create_heap(nil, nil, nil, nil, nil);
end;

procedure duk_throw(ctx: PDukContext); inline;
begin
  duk_throw_raw(ctx);
end;

procedure duk_fatal(ctx: PDukContext; const err_msg: MarshaledAString); inline;
begin
  duk_fatal_raw(ctx, err_msg);
end;

procedure duk_error(ctx: PDukContext; err_code: TDukErrCode; const fmt: MarshaledAString); inline;
begin
  duk_error_raw(ctx, err_code, nil, 0, fmt);
end;

procedure duk_generic_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
begin
  duk_error_raw(ctx, DUK_ERR_ERROR, nil, 0, fmt);
end;

procedure duk_eval_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
begin
  duk_error_raw(ctx, DUK_ERR_EVAL_ERROR, nil, 0, fmt);
end;

procedure duk_range_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
begin
  duk_error_raw(ctx, DUK_ERR_RANGE_ERROR, nil, 0, fmt);
end;

procedure duk_reference_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
begin
  duk_error_raw(ctx, DUK_ERR_REFERENCE_ERROR, nil, 0, fmt);
end;

procedure duk_syntax_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
begin
  duk_error_raw(ctx, DUK_ERR_SYNTAX_ERROR, nil, 0, fmt);
end;

procedure duk_type_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
begin
  duk_error_raw(ctx, DUK_ERR_TYPE_ERROR, nil, 0, fmt);
end;

procedure duk_uri_error(ctx: PDukContext; const fmt: MarshaledAString); inline;
begin
  duk_error_raw(ctx, DUK_ERR_URI_ERROR, nil, 0, fmt);
end;

procedure duk_xmove_top(to_ctx: PDukContext; from_ctx: PDukContext; count: TDukIdx); inline;
begin
  duk_xcopymove_raw(to_ctx, from_ctx, count, 0);
end;

procedure duk_xcopy_top(to_ctx: PDukContext; from_ctx: PDukContext; count: TDukIdx); inline;
begin
  duk_xcopymove_raw(to_ctx, from_ctx, count, 1);
end;

function duk_push_thread(ctx: PDukContext): TDukIdx; inline;
begin
  Result := duk_push_thread_raw(ctx, 0);
end;

function duk_push_thread_new_globalenv(ctx: PDukContext): TDukIdx; inline;
begin
  Result := duk_push_thread_raw(ctx, DUK_THREAD_NEW_GLOBAL_ENV);
end;

function duk_push_error_object(ctx: PDukContext; err_code: TDukErrcode; const fmt: MarshaledAString): TDukIdx; inline;
begin
  Result := duk_push_error_object_raw(ctx, err_code, nil, 0, fmt);
end;

function duk_push_buffer(ctx: PDukContext; size: TDukSize; dynamic: Boolean): Pointer; inline;
begin
  if (dynamic) then
    Result := duk_push_buffer_raw(ctx, size, DUK_BUF_FLAG_DYNAMIC)
  else
    Result := duk_push_buffer_raw(ctx, size, 0);
end;

function duk_push_fixed_buffer(ctx: PDukContext; size: TDukSize): Pointer; inline;
begin
  Result := duk_push_buffer_raw(ctx, size, 0);
end;

function duk_push_dynamic_buffer(ctx: PDukContext; size: TDukSize): Pointer; inline;
begin
  Result := duk_push_buffer_raw(ctx, size, DUK_BUF_FLAG_DYNAMIC);
end;

function duk_push_external_buffer(ctx: PDukContext): Pointer; inline;
begin
  Result := duk_push_buffer_raw(ctx, 0, DUK_BUF_FLAG_DYNAMIC or DUK_BUF_FLAG_EXTERNAL);
end;

function duk_is_null_or_undefined(ctx: PDukContext; idx: TDukIdx): TDukBool; inline;
begin
  Result := Ord((duk_get_type_mask(ctx, idx) and (DUK_TYPE_MASK_NULL or DUK_TYPE_MASK_UNDEFINED)) <> 0);
end;

function duk_is_callable(ctx: PDukContext; idx: TDukIdx): TDukBool; inline;
begin
  Result := duk_is_function(ctx, idx);
end;

function duk_is_primitive(ctx: PDukContext; idx: TDukIdx): TDukBool; inline;
begin
  Result := duk_check_type_mask(ctx, idx, DUK_TYPE_MASK_UNDEFINED or
    DUK_TYPE_MASK_NULL or DUK_TYPE_MASK_BOOLEAN or DUK_TYPE_MASK_NUMBER or
    DUK_TYPE_MASK_STRING or DUK_TYPE_MASK_POINTER);
end;

function duk_is_object_coercible(ctx: PDukContext; idx: TDukIdx): TDukBool; inline;
begin
  Result := duk_check_type_mask(ctx, idx, DUK_TYPE_MASK_BOOLEAN or
    DUK_TYPE_MASK_NUMBER or DUK_TYPE_MASK_STRING or DUK_TYPE_MASK_OBJECT or
    DUK_TYPE_MASK_BUFFER or DUK_TYPE_MASK_POINTER or DUK_TYPE_MASK_LIGHTFUNC);
end;

function duk_is_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
begin
  Result := (duk_get_error_code(ctx, idx) <> 0);
end;

function duk_is_eval_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
begin
  Result := (duk_get_error_code(ctx, idx) = DUK_ERR_EVAL_ERROR);
end;

function duk_is_range_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
begin
  Result := (duk_get_error_code(ctx, idx) = DUK_ERR_RANGE_ERROR);
end;

function duk_is_reference_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
begin
  Result := (duk_get_error_code(ctx, idx) = DUK_ERR_REFERENCE_ERROR);
end;

function duk_is_syntax_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
begin
  Result := (duk_get_error_code(ctx, idx) = DUK_ERR_SYNTAX_ERROR);
end;

function duk_is_type_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
begin
  Result := (duk_get_error_code(ctx, idx) = DUK_ERR_TYPE_ERROR);
end;

function duk_is_uri_error(ctx: PDukContext; idx: TDukIdx): Boolean; inline;
begin
  Result := (duk_get_error_code(ctx, idx) = DUK_ERR_URI_ERROR);
end;

procedure duk_require_type_mask(ctx: PDukContext; idx: TDukIdx; mask: TDukUInt); inline;
begin
  duk_check_type_mask(ctx, idx, mask or DUK_TYPE_MASK_THROW);
end;

procedure duk_require_callable(ctx: PDukContext; idx: TDukIdx); inline;
begin
  duk_require_function(ctx, idx);
end;

procedure duk_require_object_coercible(ctx: PDukContext; idx: TDukIdx); inline;
begin
  duk_check_type_mask(ctx, idx, DUK_TYPE_MASK_BOOLEAN or DUK_TYPE_MASK_NUMBER or
    DUK_TYPE_MASK_STRING or DUK_TYPE_MASK_OBJECT or DUK_TYPE_MASK_BUFFER or
    DUK_TYPE_MASK_POINTER or DUK_TYPE_MASK_LIGHTFUNC or DUK_TYPE_MASK_THROW);
end;

function duk_to_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; inline;
begin
  Result := duk_to_buffer_raw(ctx, idx, out_size, DUK_BUF_MODE_DONTCARE);
end;

function duk_to_fixed_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; inline;
begin
  Result := duk_to_buffer_raw(ctx, idx, out_size, DUK_BUF_MODE_FIXED);
end;

function duk_to_dynamic_buffer(ctx: PDukContext; idx: TDukIdx; out_size: PDukSize): Pointer; inline;
begin
  Result := duk_to_buffer_raw(ctx, idx, out_size, DUK_BUF_MODE_DYNAMIC);
end;

function duk_safe_to_string(ctx: PDukContext; idx: TDukIdx): MarshaledAString; inline;
begin
  Result := duk_safe_to_lstring(ctx, idx, nil);
end;

function duk_eval(ctx: PDukContext): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, nil, 0, 1 or DUK_COMPILE_EVAL
    or DUK_COMPILE_NOFILENAME);
end;

function duk_eval_noresult(ctx: PDukContext): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, nil, 0, 1 or DUK_COMPILE_EVAL
    or DUK_COMPILE_NOFILENAME or DUK_COMPILE_NORESULT);
end;

function duk_peval(ctx: PDukContext): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, nil, 0, 1 or DUK_COMPILE_EVAL
    or DUK_COMPILE_NOFILENAME or DUK_COMPILE_SAFE);
end;

function duk_peval_noresult(ctx: PDukContext): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, nil, 0, 1 or DUK_COMPILE_EVAL
    or DUK_COMPILE_NOFILENAME or DUK_COMPILE_SAFE or DUK_COMPILE_NORESULT);
end;

function duk_compile(ctx: PDukContext; flags: TDukUInt): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, nil, 0, 2 or flags);
end;

function duk_pcompile(ctx: PDukContext; flags: TDukUInt): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, nil, 0, 2 or flags or DUK_COMPILE_SAFE);
end;

function duk_eval_string(ctx: PDukContext; const src: MarshaledAString): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, src, 0, DUK_COMPILE_EVAL or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_STRLEN or DUK_COMPILE_NOFILENAME);
end;

function duk_eval_string_noresult(ctx: PDukContext; const src: MarshaledAString): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, src, 0, DUK_COMPILE_EVAL or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_STRLEN or DUK_COMPILE_NOFILENAME or DUK_COMPILE_NORESULT);
end;

function duk_peval_string(ctx: PDukContext; const src: MarshaledAString): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, src, 0, DUK_COMPILE_EVAL or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_STRLEN or DUK_COMPILE_NOFILENAME or DUK_COMPILE_SAFE);
end;

function duk_peval_string_noresult(ctx: PDukContext; const src: MarshaledAString): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, src, 0, DUK_COMPILE_EVAL or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_STRLEN or DUK_COMPILE_NOFILENAME or DUK_COMPILE_SAFE
    or DUK_COMPILE_NORESULT);
end;

function duk_compile_string(ctx: PDukContext; flags: TDukUInt; const src: MarshaledAString): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, nil, 0, flags or DUK_COMPILE_NOSOURCE or
    DUK_COMPILE_STRLEN or DUK_COMPILE_NOFILENAME);
end;

function duk_compile_string_filename(ctx: PDukContext; flags: TDukUInt; const src: MarshaledAString): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, nil, 0, 1 or flags or DUK_COMPILE_NOSOURCE or
    DUK_COMPILE_STRLEN);
end;

function duk_pcompile_string(ctx: PDukContext; flags: TDukUInt; const src: MarshaledAString): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, nil, 0, flags or DUK_COMPILE_NOSOURCE or
    DUK_COMPILE_STRLEN or DUK_COMPILE_NOFILENAME or DUK_COMPILE_SAFE);
end;

function duk_pcompile_string_filename(ctx: PDukContext; flags: TDukUInt; const src: MarshaledAString): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, nil, 0, 1 or flags or DUK_COMPILE_NOSOURCE or
    DUK_COMPILE_STRLEN or DUK_COMPILE_SAFE);
end;

function duk_eval_lstring(ctx: PDukContext; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, buf, len, DUK_COMPILE_EVAL or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_NOFILENAME);
end;

function duk_eval_lstring_noresult(ctx: PDukContext; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, buf, len, DUK_COMPILE_EVAL or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_NOFILENAME or DUK_COMPILE_NORESULT);
end;

function duk_peval_lstring(ctx: PDukContext; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, buf, len, DUK_COMPILE_EVAL or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_NOFILENAME or DUK_COMPILE_SAFE);
end;

function duk_peval_lstring_noresult(ctx: PDukContext; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
begin
  Result := duk_eval_raw(ctx, buf, len, DUK_COMPILE_EVAL or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_NOFILENAME or DUK_COMPILE_SAFE or DUK_COMPILE_NORESULT);
end;

function duk_compile_lstring(ctx: PDukContext; flags: TDukUInt; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, buf, len, flags or DUK_COMPILE_NOSOURCE or
    DUK_COMPILE_NOFILENAME);
end;

function duk_compile_lstring_filename(ctx: PDukContext; flags: TDukUInt; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, buf, len, 1 or flags or DUK_COMPILE_NOSOURCE);
end;

function duk_pcompile_lstring(ctx: PDukContext; flags: TDukUInt; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, buf, len, flags or DUK_COMPILE_NOSOURCE or
    DUK_COMPILE_NOFILENAME or DUK_COMPILE_SAFE);
end;

function duk_pcompile_lstring_filename(ctx: PDukContext; flags: TDukUInt; const buf: MarshaledAString; len: TDukSize): TDukInt; inline;
begin
  Result := duk_compile_raw(ctx, buf, len, 1 or flags or DUK_COMPILE_NOSOURCE
    or DUK_COMPILE_SAFE);
end;

end.
